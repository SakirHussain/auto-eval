{
  "question": "Frequency of an integer in an array is the number of occurrences of that number in the array. Given an array A of n integers, design two different algorithms each using two different design techniques to arrange the integers of A in such a way that the integers with higher frequency appear first. If two integers have the same frequency, sort them in ascending order. For the input [4,5,6,5,6,4,3,3,6,13], your pseudocode should give the output [6,6,6,3,3,4,4,5,5,13]. Your 'design' should involve all the required steps. Analyse your algorithm with all the steps involved. [15 marks]",
  "student_answers": [
    {
      "full_answer": "First Design: I will use a simple bubble sort approach based on frequencies. First I count how many times each number appears using a dictionary. Then I bubble sort the array based on the frequency counts, swapping elements if the previous has smaller frequency. If two elements have same frequency, I swap them if the left is bigger than right.\n\nExample: Array is [4,5,6,5,6,4,3,3,6,13]. After counting, 6 appears 3 times, 4 and 5 and 3 appear 2 times, and 13 once. While doing bubble sort, 6 will bubble to the front because it has highest count.\n\nSecond Design: I can use a Max Heap (priority queue) where the comparator is frequency. I insert all unique elements into the heap with frequency as key. Then I just pop elements and repeat them as many times as their frequency.\n\nPseudocode for First Design:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nfor i in range(len(A)):\n    for j in range(len(A)-i-1):\n        if frequency_map[A[j]] < frequency_map[A[j+1]]:\n            swap(A[j], A[j+1])\n        else if frequency_map[A[j]] == frequency_map[A[j+1]] and A[j] > A[j+1]:\n            swap(A[j], A[j+1])\n\nPseudocode for Second Design:\nheap = MaxHeap()\nfor num in frequency_map:\n    heap.push((frequency_map[num], num))\nresult = []\nwhile heap not empty:\n    freq, num = heap.pop()\n    result.extend([num]*freq)\n\nThe time complexity of the first approach is O(n^2) because of double for loop bubble sort. The heap approach has O(n log n) complexity because we push all elements and pop them. So both designs are efficient for large arrays.",

      "split_by_rubric": {
        "Logic": "First Design: I will use a simple bubble sort approach based on frequencies. First I count how many times each number appears using a dictionary. Then I bubble sort the array based on the frequency counts, swapping elements if the previous has smaller frequency. If two elements have same frequency, I swap them if the left is bigger than right.\n\nSecond Design: I can use a Max Heap (priority queue) where the comparator is frequency. I insert all unique elements into the heap with frequency as key. Then I just pop elements and repeat them as many times as their frequency.",

        "Illustration": "Example: Array is [4,5,6,5,6,4,3,3,6,13]. After counting, 6 appears 3 times, 4 and 5 and 3 appear 2 times, and 13 once. While doing bubble sort, 6 will bubble to the front because it has highest count.",

        "Pseudocode": "Pseudocode for First Design:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nfor i in range(len(A)):\n    for j in range(len(A)-i-1):\n        if frequency_map[A[j]] < frequency_map[A[j+1]]:\n            swap(A[j], A[j+1])\n        else if frequency_map[A[j]] == frequency_map[A[j+1]] and A[j] > A[j+1]:\n            swap(A[j], A[j+1])\n\nPseudocode for Second Design:\nheap = MaxHeap()\nfor num in frequency_map:\n    heap.push((frequency_map[num], num))\nresult = []\nwhile heap not empty:\n    freq, num = heap.pop()\n    result.extend([num]*freq)",

        "Time Complexity": "The time complexity of the first approach is O(n^2) because of double for loop bubble sort. The heap approach has O(n log n) complexity because we push all elements and pop them. So both designs are efficient for large arrays."
      }
    },
    {
      "full_answer": "First Algorithm: I will group the elements into arrays where each array contains numbers of same frequency. Then I will just join them starting from the highest frequency group to lowest. I don't need to sort inside the group because the numbers are already arranged in the input, and this preserves ascending order naturally.\n\nGiven input [4,5,6,5,6,4,3,3,6,13], the frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. So I make groups like 3->[6], 2->[4,5,3], 1->[13]. Then I append from highest group to lowest.\n\nSecond Algorithm: I sort the array first based on value, then use a custom counting array where each index represents a frequency. I traverse and whenever I find an element, I put it at the index corresponding to its frequency. After filling, I concatenate the lists from highest frequency to lowest.\n\nPseudocode First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\ngroups = {}\nfor num, freq in frequency_map.items():\n    groups[freq].append(num)\nresult = []\nfor freq in sorted(groups.keys(), reverse=True):\n    result.extend(groups[freq])\n\nPseudocode Second Algorithm:\nA.sort()\nfrequency_array = [[] for _ in range(len(A)+1)]\nfor num in A:\n    frequency_array[frequency_map[num]].append(num)\nresult = []\nfor bucket in reversed(frequency_array):\n    result.extend(bucket)\n\nTime complexity: First method is O(n + k) because grouping and joining are simple operations. Second method is O(n log n) for sorting and O(n) for filling the array, so O(n log n) overall.",

      "split_by_rubric": {
        "Logic": "First Algorithm: I will group the elements into arrays where each array contains numbers of same frequency. Then I will just join them starting from the highest frequency group to lowest. I don't need to sort inside the group because the numbers are already arranged in the input, and this preserves ascending order naturally.\n\nSecond Algorithm: I sort the array first based on value, then use a custom counting array where each index represents a frequency. I traverse and whenever I find an element, I put it at the index corresponding to its frequency. After filling, I concatenate the lists from highest frequency to lowest.",

        "Illustration": "Given input [4,5,6,5,6,4,3,3,6,13], the frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. So I make groups like 3->[6], 2->[4,5,3], 1->[13]. Then I append from highest group to lowest.",

        "Pseudocode": "Pseudocode First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\ngroups = {}\nfor num, freq in frequency_map.items():\n    groups[freq].append(num)\nresult = []\nfor freq in sorted(groups.keys(), reverse=True):\n    result.extend(groups[freq])\n\nPseudocode Second Algorithm:\nA.sort()\nfrequency_array = [[] for _ in range(len(A)+1)]\nfor num in A:\n    frequency_array[frequency_map[num]].append(num)\nresult = []\nfor bucket in reversed(frequency_array):\n    result.extend(bucket)",

        "Time Complexity": "Time complexity: First method is O(n + k) because grouping and joining are simple operations. Second method is O(n log n) for sorting and O(n) for filling the array, so O(n log n) overall."
      }
    },
    {
      "full_answer": "First Algorithm: I use insertion sort on the original array but with a special condition: I compare elements by their frequency first, and if they are same, by ascending value. Since insertion sort is stable and works well for almost sorted arrays, it will be fast here. I first calculate frequencies and then sort.\n\nExample: Given [4,5,6,5,6,4,3,3,6,13], frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. After running insertion sort using the custom comparator, it will arrange like [6,6,6,3,3,4,4,5,5,13].\n\nSecond Algorithm: I use two hashmaps, one for frequency and one reverse map from frequency to list of numbers. I iterate from max frequency down and for each frequency, I take numbers from the reverse map and insert them directly into result. No sorting inside is needed because we process numbers as we find them.\n\nPseudocode First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nfor i in range(1, len(A)):\n    j = i\n    while j > 0 and (frequency_map[A[j]] > frequency_map[A[j-1]] or (frequency_map[A[j]] == frequency_map[A[j-1]] and A[j] < A[j-1])):\n        swap(A[j], A[j-1])\n        j -= 1\n\nPseudocode Second Algorithm:\nfrequency_map = {}\nreverse_map = {}\nfor num in A:\n    frequency_map[num] += 1\nfor num, freq in frequency_map.items():\n    reverse_map[freq].append(num)\nresult = []\nfor freq in range(len(A), 0, -1):\n    result.extend(reverse_map[freq])\n\nTime Complexity: First algorithm is O(n^2) because insertion sort is quadratic, but since data is nearly sorted by value it should perform almost linear in practice. Second algorithm is O(n) for hashmap and reverse map building, and O(k) for filling output, so total O(n+k).",

      "split_by_rubric": {
        "Logic": "First Algorithm: I use insertion sort on the original array but with a special condition: I compare elements by their frequency first, and if they are same, by ascending value. Since insertion sort is stable and works well for almost sorted arrays, it will be fast here. I first calculate frequencies and then sort.\n\nSecond Algorithm: I use two hashmaps, one for frequency and one reverse map from frequency to list of numbers. I iterate from max frequency down and for each frequency, I take numbers from the reverse map and insert them directly into result. No sorting inside is needed because we process numbers as we find them.",

        "Illustration": "Example: Given [4,5,6,5,6,4,3,3,6,13], frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. After running insertion sort using the custom comparator, it will arrange like [6,6,6,3,3,4,4,5,5,13].",

        "Pseudocode": "Pseudocode First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nfor i in range(1, len(A)):\n    j = i\n    while j > 0 and (frequency_map[A[j]] > frequency_map[A[j-1]] or (frequency_map[A[j]] == frequency_map[A[j-1]] and A[j] < A[j-1])):\n        swap(A[j], A[j-1])\n        j -= 1\n\nPseudocode Second Algorithm:\nfrequency_map = {}\nreverse_map = {}\nfor num in A:\n    frequency_map[num] += 1\nfor num, freq in frequency_map.items():\n    reverse_map[freq].append(num)\nresult = []\nfor freq in range(len(A), 0, -1):\n    result.extend(reverse_map[freq])",

        "Time Complexity": "Time Complexity: First algorithm is O(n^2) because insertion sort is quadratic, but since data is nearly sorted by value it should perform almost linear in practice. Second algorithm is O(n) for hashmap and reverse map building, and O(k) for filling output, so total O(n+k)."
      }
    },
    {
      "full_answer": "First algorithm: I will use quicksort with a custom comparator that sorts by frequency descending and by value ascending if frequencies are equal. To do this, I first count frequencies in a map. Then I apply quicksort using the comparator. Since quicksort is fast for average cases, this should sort properly.\n\nExample: Array [4,5,6,5,6,4,3,3,6,13] gives frequency {4:2, 5:2, 6:3, 3:2, 13:1}. Then quicksort places 6 first, then 3 and 4 and 5 based on values, then 13 last.\n\nSecond algorithm: I use a bucket array where each index represents a frequency. I traverse the array and put numbers into buckets corresponding to their frequencies. After that, I combine the buckets from high frequency to low. No internal sorting needed because same-frequency numbers will stay in order.\n\nPseudocode for First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nquicksort(A, comparator)\n\nComparator:\nif frequency_map[a] != frequency_map[b]:\n    return frequency_map[b] - frequency_map[a]\nelse:\n    return a - b\n\nPseudocode for Second Algorithm:\nfrequency_map = {}\nbuckets = [[] for _ in range(len(A)+1)]\nfor num in A:\n    buckets[frequency_map[num]].append(num)\nresult = []\nfor freq in range(len(buckets)-1, 0, -1):\n    result.extend(buckets[freq])\n\nTime complexity: The first approach is O(n log n) on average for quicksort. Second method is O(n) because filling and joining buckets is linear.",

      "split_by_rubric": {
        "Logic": "First algorithm: I will use quicksort with a custom comparator that sorts by frequency descending and by value ascending if frequencies are equal. To do this, I first count frequencies in a map. Then I apply quicksort using the comparator. Since quicksort is fast for average cases, this should sort properly.\n\nSecond algorithm: I use a bucket array where each index represents a frequency. I traverse the array and put numbers into buckets corresponding to their frequencies. After that, I combine the buckets from high frequency to low. No internal sorting needed because same-frequency numbers will stay in order.",

        "Illustration": "Example: Array [4,5,6,5,6,4,3,3,6,13] gives frequency {4:2, 5:2, 6:3, 3:2, 13:1}. Then quicksort places 6 first, then 3 and 4 and 5 based on values, then 13 last.",

        "Pseudocode": "Pseudocode for First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nquicksort(A, comparator)\n\nComparator:\nif frequency_map[a] != frequency_map[b]:\n    return frequency_map[b] - frequency_map[a]\nelse:\n    return a - b\n\nPseudocode for Second Algorithm:\nfrequency_map = {}\nbuckets = [[] for _ in range(len(A)+1)]\nfor num in A:\n    buckets[frequency_map[num]].append(num)\nresult = []\nfor freq in range(len(buckets)-1, 0, -1):\n    result.extend(buckets[freq])",

        "Time Complexity": "Time complexity: The first approach is O(n log n) on average for quicksort. Second method is O(n) because filling and joining buckets is linear."
      }
    },
    {
      "full_answer": "First algorithm: I will build a frequency map for the array where the key is the element and value is its frequency. Then I will sort the array using a stable sort with the key being (-frequency, value), so higher frequency comes first, and for same frequencies, the smaller value comes first.\n\nExample: For input [4,5,6,5,6,4,3,3,6,13], the frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. Sorting by (-frequency, value) gives [6,6,6,3,3,4,4,5,5,13].\n\nSecond algorithm: I build (frequency, value) pairs, insert them into a max-heap using (-frequency, value) as the priority, and pop them one by one, replicating the value by its frequency. This way we always get highest frequency first and ascending value for ties.\n\nPseudocode for First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nA.sort(key=lambda x: (-frequency_map[x], x))\n\nPseudocode for Second Algorithm:\nfrequency_map = {}\nheap = []\nfor num in set(A):\n    heapq.heappush(heap, (-frequency_map[num], num))\nresult = []\nwhile heap:\n    freq, num = heapq.heappop(heap)\n    result.extend([num]*(-freq))\n\nTime Complexity: First method has O(n) for counting and O(n log n) for sorting. Second method has O(n) for counting, O(n log n) for heap operations, and O(n) for building the result, so overall O(n log n) for both methods.",

      "split_by_rubric": {
        "Logic": "First algorithm: I will build a frequency map for the array where the key is the element and value is its frequency. Then I will sort the array using a stable sort with the key being (-frequency, value), so higher frequency comes first, and for same frequencies, the smaller value comes first.\n\nSecond algorithm: I build (frequency, value) pairs, insert them into a max-heap using (-frequency, value) as the priority, and pop them one by one, replicating the value by its frequency. This way we always get highest frequency first and ascending value for ties.",

        "Illustration": "Example: For input [4,5,6,5,6,4,3,3,6,13], the frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. Sorting by (-frequency, value) gives [6,6,6,3,3,4,4,5,5,13].",

        "Pseudocode": "Pseudocode for First Algorithm:\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nA.sort(key=lambda x: (-frequency_map[x], x))\n\nPseudocode for Second Algorithm:\nfrequency_map = {}\nheap = []\nfor num in set(A):\n    heapq.heappush(heap, (-frequency_map[num], num))\nresult = []\nwhile heap:\n    freq, num = heapq.heappop(heap)\n    result.extend([num]*(-freq))",

        "Time Complexity": "Time Complexity: First method has O(n) for counting and O(n log n) for sorting. Second method has O(n) for counting, O(n log n) for heap operations, and O(n) for building the result, so overall O(n log n) for both methods."
      }
    },
    {
      "full_answer": "First algorithm: I will create a frequency array where index is the number and value is the count. Then I sort the input array using the frequency array for comparison. If two numbers have same frequency, I will sort based on higher value first because higher numbers usually should come first when there's a tie.\n\nFor the input [4,5,6,5,6,4,3,3,6,13], after counting frequencies: {4:2, 5:2, 6:3, 3:2, 13:1}. Sorting gives 6,5,5,4,4,3,3,13.\n\nSecond algorithm: I use a queue for each frequency. After counting, I push elements into queues based on their frequency. Then starting from max frequency down to 1, I dequeue elements and add them to the result array. Queues maintain insertion order, so ascending order inside same frequency is automatic.\n\nPseudocode for First Algorithm:\nfrequency = {}\nfor num in A:\n    frequency[num] += 1\nA.sort(key=lambda x: (-frequency[x], -x))\n\nPseudocode for Second Algorithm:\nfrequency = {}\nfor num in A:\n    frequency[num] += 1\nqueues = [[] for _ in range(len(A)+1)]\nfor num in frequency:\n    queues[frequency[num]].append(num)\nresult = []\nfor freq in range(len(queues)-1, 0, -1):\n    while queues[freq]:\n        result.append(queues[freq].pop(0))\n\nTime complexity: Sorting is O(n log n) in the first method, and O(n) for the second because we just fill queues and output.",

      "split_by_rubric": {
        "Logic": "First algorithm: I will create a frequency array where index is the number and value is the count. Then I sort the input array using the frequency array for comparison. If two numbers have same frequency, I will sort based on higher value first because higher numbers usually should come first when there's a tie.\n\nSecond algorithm: I use a queue for each frequency. After counting, I push elements into queues based on their frequency. Then starting from max frequency down to 1, I dequeue elements and add them to the result array. Queues maintain insertion order, so ascending order inside same frequency is automatic.",

        "Illustration": "For the input [4,5,6,5,6,4,3,3,6,13], after counting frequencies: {4:2, 5:2, 6:3, 3:2, 13:1}. Sorting gives 6,5,5,4,4,3,3,13.",

        "Pseudocode": "Pseudocode for First Algorithm:\nfrequency = {}\nfor num in A:\n    frequency[num] += 1\nA.sort(key=lambda x: (-frequency[x], -x))\n\nPseudocode for Second Algorithm:\nfrequency = {}\nfor num in A:\n    frequency[num] += 1\nqueues = [[] for _ in range(len(A)+1)]\nfor num in frequency:\n    queues[frequency[num]].append(num)\nresult = []\nfor freq in range(len(queues)-1, 0, -1):\n    while queues[freq]:\n        result.append(queues[freq].pop(0))",

        "Time Complexity": "Time complexity: Sorting is O(n log n) in the first method, and O(n) for the second because we just fill queues and output."
      }
    },
    {
      "full_answer": "First method: Just build a frequency map of the elements first. Then, sort the array with a custom key: sort by negative frequency (higher freq first) and value (lower number first) when tie. Python's sort is stable so it'll preserve relative order properly.\n\nTaking input [4,5,6,5,6,4,3,3,6,13], frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. After sorting by key (-freq, val), we get [6,6,6,3,3,4,4,5,5,13].\n\nSecond method: Use a heap (priority queue). For every unique number, push (-frequency, number) into the heap. Then pop from heap, and repeat the number according to its frequency.\n\nPseudocode First Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num, 0) + 1\nA.sort(key=lambda x: (-frequency[x], x))\n\nPseudocode Second Method:\nimport heapq\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num, 0) + 1\nheap = []\nfor num in frequency:\n    heapq.heappush(heap, (-frequency[num], num))\nresult = []\nwhile heap:\n    freq, num = heapq.heappop(heap)\n    result.extend([num]*(-freq))\n\nTime complexity: Both methods are O(n log n) because of sort and heap push/pop, plus O(n) for frequency counting and final output.",

      "split_by_rubric": {
        "Logic": "First method: Just build a frequency map of the elements first. Then, sort the array with a custom key: sort by negative frequency (higher freq first) and value (lower number first) when tie. Python's sort is stable so it'll preserve relative order properly.\n\nSecond method: Use a heap (priority queue). For every unique number, push (-frequency, number) into the heap. Then pop from heap, and repeat the number according to its frequency.",

        "Illustration": "Taking input [4,5,6,5,6,4,3,3,6,13], frequency map is {4:2, 5:2, 6:3, 3:2, 13:1}. After sorting by key (-freq, val), we get [6,6,6,3,3,4,4,5,5,13].",

        "Pseudocode": "Pseudocode First Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num, 0) + 1\nA.sort(key=lambda x: (-frequency[x], x))\n\nPseudocode Second Method:\nimport heapq\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num, 0) + 1\nheap = []\nfor num in frequency:\n    heapq.heappush(heap, (-frequency[num], num))\nresult = []\nwhile heap:\n    freq, num = heapq.heappop(heap)\n    result.extend([num]*(-freq))",

        "Time Complexity": "Time complexity: Both methods are O(n log n) because of sort and heap push/pop, plus O(n) for frequency counting and final output."
      }
    },
    {
      "full_answer": "First algorithm: To arrange elements by frequency, I will simply sort the array based on the value of elements first, then count how many times each element appears and reinsert them according to their counts. Higher numbers will obviously have higher frequencies in most cases so sorting the array ascendingly is sufficient.\n\nFor input [4,5,6,5,6,4,3,3,6,13], after sorting we get [3,3,4,4,5,5,6,6,6,13], which is already mostly frequency sorted.\n\nSecond algorithm: I can use a single pass greedy approach. Start from the beginning, and whenever two same numbers are found together, leave them. If different numbers are found, swap them with any number which has a match later.\n\nPseudocode for First Algorithm:\nA.sort()\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nresult = []\nfor num in A:\n    result.extend([num]*frequency_map[num])\n\nPseudocode for Second Algorithm:\nfor i in range(len(A)):\n    for j in range(i+1, len(A)):\n        if A[i] != A[j] and A.count(A[i]) < A.count(A[j]):\n            swap(A[i], A[j])\n\nTime complexity: First method is O(n log n) for sorting and O(n) for counting, so O(n log n) overall. Second method is O(n^2) because of double loops but it works well for small arrays.",

      "split_by_rubric": {
        "Logic": "First algorithm: To arrange elements by frequency, I will simply sort the array based on the value of elements first, then count how many times each element appears and reinsert them according to their counts. Higher numbers will obviously have higher frequencies in most cases so sorting the array ascendingly is sufficient.\n\nSecond algorithm: I can use a single pass greedy approach. Start from the beginning, and whenever two same numbers are found together, leave them. If different numbers are found, swap them with any number which has a match later.",

        "Illustration": "For input [4,5,6,5,6,4,3,3,6,13], after sorting we get [3,3,4,4,5,5,6,6,6,13], which is already mostly frequency sorted.",

        "Pseudocode": "Pseudocode for First Algorithm:\nA.sort()\nfrequency_map = {}\nfor num in A:\n    frequency_map[num] += 1\nresult = []\nfor num in A:\n    result.extend([num]*frequency_map[num])\n\nPseudocode for Second Algorithm:\nfor i in range(len(A)):\n    for j in range(i+1, len(A)):\n        if A[i] != A[j] and A.count(A[i]) < A.count(A[j]):\n            swap(A[i], A[j])",

        "Time Complexity": "Time complexity: First method is O(n log n) for sorting and O(n) for counting, so O(n log n) overall. Second method is O(n^2) because of double loops but it works well for small arrays."
      }
    },
    {
      "full_answer": "First method: Since the question asks for sorting based on how often a number appears, I can assume that simply reversing the array after sorting will bring the most repeated numbers first. High numbers usually appear more so sorting descendingly should work. Just sort and reverse.\n\nExample: After sorting input [4,5,6,5,6,4,3,3,6,13], it becomes [13,6,6,6,5,5,4,4,3,3]. This places highest values early which usually matches high frequencies.\n\nSecond method: I propose using a graph approach where every number is treated as a node, and edges are drawn between same numbers. Then I traverse the graph starting from the node with maximum edges. DFS traversal will bring the numbers that appeared more first.\n\nPseudocode for First Method:\nA.sort(reverse=True)\n\nPseudocode for Second Method:\nBuild graph G where edge between same numbers\nvisited = set()\ndef dfs(node):\n    if node not in visited:\n        result.append(node)\n        visited.add(node)\n        for neighbor in G[node]:\n            dfs(neighbor)\nfor num in A:\n    if num not in visited:\n        dfs(num)\n\nTime complexity: First method O(n log n) for sort. Second method is O(n) for building graph and O(n) for DFS traversal, so very efficient.",

      "split_by_rubric": {
        "Logic": "First method: Since the question asks for sorting based on how often a number appears, I can assume that simply reversing the array after sorting will bring the most repeated numbers first. High numbers usually appear more so sorting descendingly should work. Just sort and reverse.\n\nSecond method: I propose using a graph approach where every number is treated as a node, and edges are drawn between same numbers. Then I traverse the graph starting from the node with maximum edges. DFS traversal will bring the numbers that appeared more first.",

        "Illustration": "Example: After sorting input [4,5,6,5,6,4,3,3,6,13], it becomes [13,6,6,6,5,5,4,4,3,3]. This places highest values early which usually matches high frequencies.",

        "Pseudocode": "Pseudocode for First Method:\nA.sort(reverse=True)\n\nPseudocode for Second Method:\nBuild graph G where edge between same numbers\nvisited = set()\ndef dfs(node):\n    if node not in visited:\n        result.append(node)\n        visited.add(node)\n        for neighbor in G[node]:\n            dfs(neighbor)\nfor num in A:\n    if num not in visited:\n        dfs(num)",

        "Time Complexity": "Time complexity: First method O(n log n) for sort. Second method is O(n) for building graph and O(n) for DFS traversal, so very efficient."
      }
    },
    {
      "full_answer": "First method: I will build a frequency table by counting how often each number occurs. Then I sort the array based on (-frequency, value). To do that, I can sort the array twice: first by value ascending and then by frequency descending so the stable sort handles the tie. This way elements with higher frequency come first and ties break by value.\n\nGiven [4,5,6,5,6,4,3,3,6,13], frequency map: {4:2, 5:2, 6:3, 3:2, 13:1}. Sorting first by value gives [3,3,4,4,5,5,6,6,6,13]. Sorting by frequency next arranges [6,6,6,3,3,4,4,5,5,13].\n\nSecond method: Use a max heap where each element is pushed as (-frequency, value). Pop from heap and write the number into the result as many times as its frequency. Heap ensures highest frequency comes first.\n\nPseudocode for First Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num,0)+1\nA.sort()\nA.sort(key=lambda x: -frequency[x])\n\nPseudocode for Second Method:\nheap = []\nfor num in set(A):\n    heapq.heappush(heap, (-frequency[num], num))\nresult = []\nwhile heap:\n    freq, num = heapq.heappop(heap)\n    result.extend([num]*freq)\n\nTime complexity: Building frequency table is O(n), first sort O(n log n), second sort O(n log n), so total is O(n log n). Heap method also takes O(n log n).",

      "split_by_rubric": {
        "Logic": "First method: I will build a frequency table by counting how often each number occurs. Then I sort the array based on (-frequency, value). To do that, I can sort the array twice: first by value ascending and then by frequency descending so the stable sort handles the tie. This way elements with higher frequency come first and ties break by value.\n\nSecond method: Use a max heap where each element is pushed as (-frequency, value). Pop from heap and write the number into the result as many times as its frequency. Heap ensures highest frequency comes first.",

        "Illustration": "Given [4,5,6,5,6,4,3,3,6,13], frequency map: {4:2, 5:2, 6:3, 3:2, 13:1}. Sorting first by value gives [3,3,4,4,5,5,6,6,6,13]. Sorting by frequency next arranges [6,6,6,3,3,4,4,5,5,13].",

        "Pseudocode": "Pseudocode for First Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num,0)+1\nA.sort()\nA.sort(key=lambda x: -frequency[x])\n\nPseudocode for Second Method:\nheap = []\nfor num in set(A):\n    heapq.heappush(heap, (-frequency[num], num))\nresult = []\nwhile heap:\n    freq, num = heapq.heappop(heap)\n    result.extend([num]*freq)",

        "Time Complexity": "Time complexity: Building frequency table is O(n), first sort O(n log n), second sort O(n log n), so total is O(n log n). Heap method also takes O(n log n)."
      }
    },
    {
      "full_answer": "First method: To solve it, first create a map of each number and how many times it appears. Then, create a list of tuples (number, frequency). Sort this list by frequency descending, and if same frequency, then by number ascending. After sorting, rebuild the result array by repeating each number its number of times.\n\nInput [4,5,6,5,6,4,3,3,6,13], frequency is {4:2,5:2,6:3,3:2,13:1}. Sorting tuples by (-freq, num) gives (6,3), (3,2), (4,2), (5,2), (13,1). So output [6,6,6,3,3,4,4,5,5,13].\n\nSecond method: I create buckets indexed by frequency. For each unique number, I place it in the bucket matching its frequency. Then I read buckets from high frequency to low, and inside each bucket sort numbers ascendingly to satisfy tie-breaking.\n\nPseudocode First Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num,0)+1\ntuples = [(num, frequency[num]) for num in frequency]\ntuples.sort(key=lambda x: (-x[1], x[0]))\nresult = []\nfor num, freq in tuples:\n    result.extend([num]*freq)\n\nPseudocode Second Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num,0)+1\nbuckets = [[] for _ in range(len(A)+1)]\nfor num in frequency:\n    buckets[frequency[num]].append(num)\nresult = []\nfor freq in range(len(buckets)-1, 0, -1):\n    result.extend(sorted(buckets[freq]))\n\nTime complexity: Sorting tuples is O(n log n), building frequency is O(n). Bucket method is O(n+k log k) where k is unique numbers, assuming bucket sorting costs log k inside each bucket.",

      "split_by_rubric": {
        "Logic": "First method: To solve it, first create a map of each number and how many times it appears. Then, create a list of tuples (number, frequency). Sort this list by frequency descending, and if same frequency, then by number ascending. After sorting, rebuild the result array by repeating each number its number of times.\n\nSecond method: I create buckets indexed by frequency. For each unique number, I place it in the bucket matching its frequency. Then I read buckets from high frequency to low, and inside each bucket sort numbers ascendingly to satisfy tie-breaking.",

        "Illustration": "Input [4,5,6,5,6,4,3,3,6,13], frequency is {4:2,5:2,6:3,3:2,13:1}. Sorting tuples by (-freq, num) gives (6,3), (3,2), (4,2), (5,2), (13,1). So output [6,6,6,3,3,4,4,5,5,13].",

        "Pseudocode": "Pseudocode First Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num,0)+1\ntuples = [(num, frequency[num]) for num in frequency]\ntuples.sort(key=lambda x: (-x[1], x[0]))\nresult = []\nfor num, freq in tuples:\n    result.extend([num]*freq)\n\nPseudocode Second Method:\nfrequency = {}\nfor num in A:\n    frequency[num] = frequency.get(num,0)+1\nbuckets = [[] for _ in range(len(A)+1)]\nfor num in frequency:\n    buckets[frequency[num]].append(num)\nresult = []\nfor freq in range(len(buckets)-1, 0, -1):\n    result.extend(sorted(buckets[freq]))",

        "Time Complexity": "Time complexity: Sorting tuples is O(n log n), building frequency is O(n). Bucket method is O(n+k log k) where k is unique numbers, assuming bucket sorting costs log k inside each bucket."
      }
    }
  ]
}
